[1mdiff --git a/entities/ai_player.py b/entities/ai_player.py[m
[1mindex 74a87ca..4dc9028 100644[m
[1m--- a/entities/ai_player.py[m
[1m+++ b/entities/ai_player.py[m
[36m@@ -3,30 +3,107 @@[m [mimport random[m
 from collections import deque[m
 from constants import *[m
 from entities.player_base import PlayerBase[m
[32m+[m[32mfrom algorithms.movement_algorithms import AIPlayerMovementStrategy, MovementAlgorithms[m
 import math[m
 [m
 [m
 class AIPlayer(PlayerBase):[m
[31m-    def __init__(self, player_id, start_x, start_y, sprite_manager, ai_type="simple"):[m
[32m+[m
[32m+[m[32m    def __init__(self, player_id, start_x, start_y, sprite_manager, ai_type="pellet_hunter_safe"):[m
         super().__init__(player_id, start_x, start_y, sprite_manager)[m
         self.direction = "LEFT"[m
         self.next_direction = "LEFT"[m
         self.speed = AI_SPEED[m
         self.ai_type = ai_type[m
         self.path = [][m
[32m+[m[32m        self.current_path_index = 0[m
         self.target = None[m
         self.decision_timer = 0[m
 [m
[31m-    def update(self, maze, player_position=None):[m
[32m+[m[32m        # Add stuck detection[m
[32m+[m[32m        self.stuck_counter = 0[m
[32m+[m[32m        self.last_position = (start_x, start_y)[m
[32m+[m[32m        self.position_check_timer = 0[m
[32m+[m
[32m+[m[32m        # Initialize movement strategy[m
[32m+[m[32m        self.movement_strategy = AIPlayerMovementStrategy(self)[m
[32m+[m[32m        self.movement_strategy.set_strategy(ai_type)[m
[32m+[m[32m        self.algorithms = MovementAlgorithms()[m
[32m+[m
[32m+[m[32m        # Grid-based movement history for decision making[m
[32m+[m[32m        self.movement_history = [][m
[32m+[m[32m        self.max_history_length = 10[m
[32m+[m
[32m+[m[32m        # Ghost tracking for avoidance[m
[32m+[m[32m        self.last_known_ghost_positions = [][m
[32m+[m
[32m+[m[32m        # Add this line[m
[32m+[m[32m        self.problematic_pellets = set()[m
[32m+[m
[32m+[m[32m        # New path stuck counter[m
[32m+[m[32m        self.path_stuck_counter = 0[m
[32m+[m
[32m+[m[32m        # Add these new attributes for problematic pellet management[m
[32m+[m[32m        self.problematic_pellets_eaten_backwards = []  # Track order of backward eating[m
[32m+[m
[32m+[m[32m    def should_ignore_problematic_pellets(self, maze):[m
[32m+[m[32m        """Check if we should ignore problematic pellets based on game state"""[m
[32m+[m[32m        total_pellets = len(maze.pellets) + len(maze.power_pellets)[m
[32m+[m
[32m+[m[32m        # If all remaining pellets are problematic, we must eat them[m
[32m+[m[32m        if total_pellets > 0 and len(self.problematic_pellets) >= total_pellets:[m
[32m+[m[32m            return False[m
[32m+[m
[32m+[m[32m        # If there are non-problematic pellets available, avoid problematic ones[m
[32m+[m[32m        return True[m
[32m+[m
[32m+[m[32m    def get_non_problematic_pellets(self, maze):[m
[32m+[m[32m        """Get all pellets that are not in the problematic list"""[m
[32m+[m[32m        all_pellets = set(maze.pellets) | set(maze.power_pellets)[m
[32m+[m[32m        return all_pellets - self.problematic_pellets[m
[32m+[m
[32m+[m[32m    def get_last_problematic_pellet_to_eat(self):[m
[32m+[m[32m        """Get the next problematic pellet to eat when going backwards through the list"""[m
[32m+[m[32m        if not self.problematic_pellets:[m
[32m+[m[32m            return None[m
[32m+[m
[32m+[m[32m        # Get pellets not yet eaten backwards[m
[32m+[m[32m        remaining_problematic = self.problematic_pellets - set(self.problematic_pellets_eaten_backwards)[m
[32m+[m
[32m+[m[32m        if remaining_problematic:[m
[32m+[m[32m            # Return the most recently added problematic pellet[m
[32m+[m[32m            return max(remaining_problematic, key=lambda p: list(self.problematic_pellets).index(p) if p in self.problematic_pellets else -1)[m
[32m+[m
[32m+[m[32m        # If all have been eaten backwards, clear the backwards list and start over[m
[32m+[m[32m        self.problematic_pellets_eaten_backwards.clear()[m
[32m+[m[32m        if self.problematic_pellets:[m
[32m+[m[32m            return max(self.problematic_pellets, key=lambda p: list(self.problematic_pellets).index(p))[m
[32m+[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m[32m    def update(self, maze, player_position=None, ghost_positions=None):[m
         # Use base class methods[m
         self.update_invincibility()[m
         self.update_animation()[m
 [m
[32m+[m[32m        # Update ghost tracking[m
[32m+[m[32m        if ghost_positions:[m
[32m+[m[32m            self.last_known_ghost_positions = [pos for pos in ghost_positions if pos is not None][m
[32m+[m
[32m+[m[32m        # Check if we're stuck[m
[32m+[m[32m        self._check_if_stuck()[m
[32m+[m
         self.decision_timer += 1[m
 [m
[31m-        # Make decisions every few frames to avoid too frequent changes[m
[31m-        if self.decision_timer >= 10:[m
[31m-            self._make_decision(maze, player_position)[m
[32m+[m[32m        # Make decisions more frequently when in danger or stuck[m
[32m+[m[32m        decision_frequency = 3 if (self._is_in_danger() or self.stuck_counter > 30) else 10[m
[32m+[m
[32m+[m[32m        # New condition: if in a tight space, increase decision frequency[m
[32m+[m[32m        if self._is_in_tight_space(maze):[m
[32m+[m[32m            decision_frequency = 2[m
[32m+[m
[32m+[m[32m        if self.decision_timer >= decision_frequency:[m
[32m+[m[32m            self._make_decision(maze, player_position, ghost_positions)[m
             self.decision_timer = 0[m
 [m
         # Check if we can change direction[m
[36m@@ -49,184 +126,258 @@[m [mclass AIPlayer(PlayerBase):[m
 [m
             if self.movement_progress >= 1.0:[m
                 # Reached next cell[m
[32m+[m[32m                old_pos = (self.grid_x, self.grid_y)[m
                 self.grid_x = target_x[m
                 self.grid_y = target_y[m
                 self.movement_progress = 0.0[m
 [m
[31m-                # Collect pellets[m
[32m+[m[32m                # Reset stuck counter since we moved[m
[32m+[m[32m                self.stuck_counter = 0[m
[32m+[m
[32m+[m[32m                # Update path index if following a path[m
[32m+[m[32m                if self.path and self.current_path_index < len(self.path):[m
[32m+[m[32m                    if (self.grid_x, self.grid_y) == self.path[self.current_path_index]:[m
[32m+[m[32m                        self.path_stuck_counter += 1[m
[32m+[m[32m                        if self.path_stuck_counter > 10:[m
[32m+[m[32m                            # Blacklist and reset[m
[32m+[m[32m                            self.problematic_pellets.add(self.path[-1])[m
[32m+[m[32m                            self.path.clear()[m
[32m+[m[32m                            self.current_path_index = 0[m
[32m+[m[32m                            self.path_stuck_counter = 0[m
[32m+[m[32m                    else:[m
[32m+[m[32m                        self.path_stuck_counter = 0[m
[32m+[m
[32m+[m[32m                # Add to movement history for trail[m
[32m+[m[32m                self.movement_history.append(old_pos)[m
[32m+[m[32m                if len(self.movement_history) > self.max_history_length:[m
[32m+[m[32m                    self.movement_history.pop(0)[m
[32m+[m
[32m+[m[32m                # Collect pellets and handle problematic pellet tracking[m
                 points = maze.collect_pellet(self.grid_x, self.grid_y)[m
[32m+[m[32m                if points > 0:[m
[32m+[m[32m                    current_pos = (self.grid_x, self.grid_y)[m
[32m+[m[32m                    # If we ate a problematic pellet, add it to the backwards eaten list[m
[32m+[m[32m                    if current_pos in self.problematic_pellets:[m
[32m+[m[32m                        if current_pos not in self.problematic_pellets_eaten_backwards:[m
[32m+[m[32m                            self.problematic_pellets_eaten_backwards.append(current_pos)[m
[32m+[m[32m                        # Remove from problematic list once eaten[m
[32m+[m[32m                        self.problematic_pellets.discard(current_pos)[m
[32m+[m
                 self.score += points[m
         else:[m
             self.moving = False[m
             self.movement_progress = 0.0[m
[31m-            # If can't move, try a different direction[m
[31m-            self._find_alternative_direction(maze)[m
[32m+[m[32m            self.stuck_counter += 1[m
[32m+[m
[32m+[m[32m            # If stuck for too long, clear path and find alternative[m
[32m+[m[32m            if self.stuck_counter > 20:[m
[32m+[m[32m                print(f"AI {self.player_id}: Stuck for {self.stuck_counter} frames, clearing path")[m
[32m+[m[32m                self.path.clear()[m
[32m+[m[32m                self.current_path_index = 0[m
[32m+[m[32m                self._find_alternative_direction(maze)[m
 [m
         # Update pixel position for smooth movement[m
         self._update_pixel_position()[m
 [m
[31m-    def _make_decision(self, maze, player_position=None):[m
[32m+[m[32m    def _check_if_stuck(self):[m
[32m+[m[32m        self.position_check_timer += 1[m
[32m+[m[32m        if self.position_check_timer >= 60:[m
[32m+[m[32m            current_pos = (self.grid_x, self.grid_y)[m
[32m+[m[32m            if current_pos == self.last_position:[m
[32m+[m[32m                self.stuck_counter += 10[m
[32m+[m[32m                # If stuck for too long, blacklist current target[m
[32m+[m[32m                if self.path and self.current_path_index < len(self.path):[m
[32m+[m[32m                    self.problematic_pellets.add(self.path[-1])[m
[32m+[m[32m                    self.path.clear()[m
[32m+[m[32m                    self.current_path_index = 0[m
[32m+[m[32m            else:[m
[32m+[m[32m                self.stuck_counter = max(0, self.stuck_counter - 5)[m
[32m+[m[32m            self.last_position = current_pos[m
[32m+[m[32m            self.position_check_timer = 0[m
[32m+[m
[32m+[m[32m    def _is_in_danger(self):[m
[32m+[m[32m        current_pos = (self.grid_x, self.grid_y)[m
[32m+[m[32m        for ghost_pos in self.last_known_ghost_positions:[m
[32m+[m[32m            if ghost_pos:[m
[32m+[m[32m                distance = self.algorithms.heuristic(current_pos, ghost_pos)[m
[32m+[m[32m                if distance <= 3 and not self.is_invincible:[m
[32m+[m[32m                    return True[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m[32m    def _is_in_tight_space(self, maze):[m
[32m+[m[32m        walls = 0[m
[32m+[m[32m        for dx, dy in DIRECTIONS.values():[m
[32m+[m[32m            if not maze.is_valid_position(self.grid_x + dx, self.grid_y + dy):[m
[32m+[m[32m                walls += 1[m
[32m+[m[32m        return walls >= 3[m
[32m+[m
[32m+[m[32m    def _make_decision(self, maze, player_position=None, ghost_positions=None):[m
         # Skip decision making if dead[m
         if self.is_dead():[m
             return[m
 [m
[31m-        if self.ai_type == "simple":[m
[31m-            self._simple_ai(maze)[m
[31m-        elif self.ai_type == "pellet_hunter":[m
[31m-            self._pellet_hunter_ai(maze)[m
[31m-        elif self.ai_type == "competitive":[m
[31m-            self._competitive_ai(maze, player_position)[m
[31m-        else:[m
[31m-            self._simple_ai(maze)[m
[31m-[m
[31m-    def _simple_ai(self, maze):[m
[31m-        # Get valid directions[m
[31m-        valid_directions = [][m
[31m-        for direction, (dx, dy) in DIRECTIONS.items():[m
[31m-            new_x = self.grid_x + dx[m
[31m-            new_y = self.grid_y + dy[m
[31m-            if maze.is_valid_position(new_x, new_y):[m
[31m-                valid_directions.append(direction)[m
[32m+[m[32m        # If stuck for a while, force a new path calculation[m
[32m+[m[32m        if self.stuck_counter > 30:[m
[32m+[m[32m            print(f"AI {self.player_id}: Stuck detected, forcing new decision")[m
[32m+[m[32m            self.path.clear()[m
[32m+[m[32m            self.current_path_index = 0[m
[32m+[m
[32m+[m[32m        # Enhanced debug output[m
[32m+[m[32m        if self.decision_timer % 60 == 0:  # Print every second[m
[32m+[m[32m            pellet_count = len(maze.pellets) + len(maze.power_pellets)[m
[32m+[m[32m            print([m
[32m+[m[32m                f"AI {self.player_id}: Strategy={self.get_current_strategy()}, "[m
[32m+[m[32m                f"Pos=({self.grid_x},{self.grid_y}), "[m
[32m+[m[32m                f"Danger={self.get_danger_level()}, "[m
[32m+[m[32m                f"Path_len={len(self.path)}, "[m
[32m+[m[32m                f"Path_idx={self.current_path_index}, "[m
[32m+[m[32m                f"Stuck={self.stuck_counter}, "[m
[32m+[m[32m                f"Ghost_pos={ghost_positions}, "[m
[32m+[m[32m                f"Pellets_left={pellet_count}"[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        success = self.movement_strategy.execute_strategy(maze, player_position, ghost_positions, self.is_invincible)[m
[32m+[m
[32m+[m[32m        # When pathfinding fails:[m
[32m+[m[32m        if not success:[m
[32m+[m[32m            # If the target is a pellet, blacklist it[m
[32m+[m[32m            if self.path and self.current_path_index < len(self.path):[m
[32m+[m[32m                self.problematic_pellets.add(self.path[-1])[m
[32m+[m[32m            print(f"AI {self.player_id}: Strategy execution FAILED - using fallback")[m
[32m+[m[32m            # Fallback to simple movement[m
[32m+[m[32m            self._find_alternative_direction(maze)[m
 [m
[31m-        if valid_directions:[m
[31m-            # Prefer continuing in the same direction if possible[m
[31m-            if self.direction in valid_directions and random.random() < 0.7:[m
[31m-                self.next_direction = self.direction[m
[31m-            else:[m
[31m-                self.next_direction = random.choice(valid_directions)[m
[31m-[m
[31m-    def _pellet_hunter_ai(self, maze):[m
[31m-        # Find nearest pellet[m
[31m-        nearest_pellet = self._find_nearest_pellet(maze)[m
[31m-        if nearest_pellet:[m
[31m-            path = self._find_path_to_target(maze, nearest_pellet)[m
[31m-            if path and len(path) > 1:[m
[31m-                next_pos = path[1]  # First step in path[m
[31m-                self._set_direction_to_position(next_pos)[m
[31m-            else:[m
[31m-                self._simple_ai(maze)  # Fallback[m
[31m-        else:[m
[31m-            self._simple_ai(maze)  # No pellets left[m
[31m-[m
[31m-    def _competitive_ai(self, maze, player_position):[m
[31m-        if player_position:[m
[31m-            # If close to player, try to move away or compete for pellets[m
[31m-            distance = abs(self.grid_x - player_position[0]) + abs(self.grid_y - player_position[1])[m
[31m-            if distance < 5:[m
[31m-                # Move away from player[m
[31m-                self._move_away_from_position(maze, player_position)[m
[31m-            else:[m
[31m-                # Hunt pellets normally[m
[31m-                self._pellet_hunter_ai(maze)[m
[31m-        else:[m
[31m-            self._pellet_hunter_ai(maze)[m
[31m-[m
[31m-    # Find the nearest pellet (regular or power) based on Manhattan distance[m
[31m-    def _find_nearest_pellet(self, maze):[m
[31m-        nearest = None[m
[31m-        min_distance = float("inf")[m
[31m-[m
[31m-        # Check regular pellets[m
[31m-        for pellet_pos in maze.pellets:[m
[31m-            distance = abs(self.grid_x - pellet_pos[0]) + abs(self.grid_y - pellet_pos[1])[m
[31m-            if distance < min_distance:[m
[31m-                min_distance = distance[m
[31m-                nearest = pellet_pos[m
[31m-[m
[31m-        # Check power pellets (higher priority)[m
[31m-        for pellet_pos in maze.power_pellets:[m
[31m-            distance = abs(self.grid_x - pellet_pos[0]) + abs(self.grid_y - pellet_pos[1])[m
[31m-            if distance < min_distance * 1.5:  # Give power pellets priority[m
[31m-                min_distance = distance[m
[31m-                nearest = pellet_pos[m
[31m-[m
[31m-        return nearest[m
[31m-[m
[31m-    # Find a path to the target position using BFS[m
[31m-    def _find_path_to_target(self, maze, target):[m
[31m-        start = (self.grid_x, self.grid_y)[m
[31m-        if start == target:[m
[31m-            return [start][m
[31m-[m
[31m-        queue = deque([(start, [start])])[m
[31m-        visited = {start}[m
[31m-[m
[31m-        while queue:[m
[31m-            (x, y), path = queue.popleft()[m
[31m-[m
[31m-            for new_x, new_y, direction in maze.get_neighbors(x, y):[m
[31m-                if (new_x, new_y) == target:[m
[31m-                    return path + [(new_x, new_y)][m
[31m-[m
[31m-                if (new_x, new_y) not in visited:[m
[31m-                    visited.add((new_x, new_y))[m
[31m-                    queue.append(((new_x, new_y), path + [(new_x, new_y)]))[m
[31m-[m
[31m-        return []  # No path found[m
[31m-[m
[31m-    def _set_direction_to_position(self, target_pos):[m
[31m-        dx = target_pos[0] - self.grid_x[m
[31m-        dy = target_pos[1] - self.grid_y[m
[31m-[m
[31m-        if dx > 0:[m
[31m-            self.next_direction = "RIGHT"[m
[31m-        elif dx < 0:[m
[31m-            self.next_direction = "LEFT"[m
[31m-        elif dy > 0:[m
[31m-            self.next_direction = "DOWN"[m
[31m-        elif dy < 0:[m
[31m-            self.next_direction = "UP"[m
[31m-[m
[31m-    def _move_away_from_position(self, maze, position):[m
[31m-        # Calculate opposite direction[m
[31m-        dx = self.grid_x - position[0][m
[31m-        dy = self.grid_y - position[1][m
[31m-[m
[31m-        # Prefer moving in the direction that increases distance[m
[31m-        preferred_directions = [][m
[31m-        if dx > 0:[m
[31m-            preferred_directions.append("RIGHT")[m
[31m-        elif dx < 0:[m
[31m-            preferred_directions.append("LEFT")[m
[31m-[m
[31m-        if dy > 0:[m
[31m-            preferred_directions.append("DOWN")[m
[31m-        elif dy < 0:[m
[31m-            preferred_directions.append("UP")[m
[31m-[m
[31m-        # Try preferred directions[m
[31m-        for direction in preferred_directions:[m
[31m-            dx, dy = DIRECTIONS[direction][m
[31m-            new_x = self.grid_x + dx[m
[31m-            new_y = self.grid_y + dy[m
[31m-            if maze.is_valid_position(new_x, new_y):[m
[32m+[m[32m        # Follow the path if we have one[m
[32m+[m[32m        if self.path and self.current_path_index < len(self.path):[m
[32m+[m[32m            next_pos = self.path[self.current_path_index][m
[32m+[m[32m            direction = self.algorithms.position_to_direction((self.grid_x, self.grid_y), next_pos)[m
[32m+[m[32m            if direction:[m
                 self.next_direction = direction[m
[31m-                return[m
[31m-[m
[31m-        # Fallback to simple AI[m
[31m-        self._simple_ai(maze)[m
[32m+[m[32m            else:[m
[32m+[m[32m                print(f"AI {self.player_id}: Could not determine direction to {next_pos}, clearing path")[m
[32m+[m[32m                self.path.clear()[m
[32m+[m[32m                self.current_path_index = 0[m
 [m
     def _find_alternative_direction(self, maze):[m
         valid_directions = [][m
[32m+[m[32m        safe_directions = [][m
[32m+[m
         for direction, (dx, dy) in DIRECTIONS.items():[m
             new_x = self.grid_x + dx[m
             new_y = self.grid_y + dy[m
             if maze.is_valid_position(new_x, new_y):[m
                 valid_directions.append(direction)[m
 [m
[31m-        if valid_directions:[m
[32m+[m[32m                # Check if this direction is safe from ghosts[m
[32m+[m[32m                is_safe = True[m
[32m+[m[32m                if not self.is_invincible:[m
[32m+[m[32m                    for ghost_pos in self.last_known_ghost_positions:[m
[32m+[m[32m                        if ghost_pos:[m
[32m+[m[32m                            distance = self.algorithms.heuristic((new_x, new_y), ghost_pos)[m
[32m+[m[32m                            if distance <= 2:  # Too close to ghost[m
[32m+[m[32m                                is_safe = False[m
[32m+[m[32m                                break[m
[32m+[m
[32m+[m[32m                if is_safe:[m
[32m+[m[32m                    safe_directions.append(direction)[m
[32m+[m
[32m+[m[32m        # Prefer safe directions[m
[32m+[m[32m        preferred_directions = safe_directions if safe_directions else valid_directions[m
[32m+[m
[32m+[m[32m        if preferred_directions:[m
             # Prefer any direction except the opposite of current[m
             opposite = {"UP": "DOWN", "DOWN": "UP", "LEFT": "RIGHT", "RIGHT": "LEFT"}[m
[31m-            preferred = [d for d in valid_directions if d != opposite.get(self.direction)][m
[31m-            if preferred:[m
[31m-                self.next_direction = random.choice(preferred)[m
[32m+[m[32m            non_opposite = [d for d in preferred_directions if d != opposite.get(self.direction)][m
[32m+[m[32m            if non_opposite:[m
[32m+[m[32m                self.next_direction = random.choice(non_opposite)[m
[32m+[m[32m            else:[m
[32m+[m[32m                # In case all preferred directions are opposite, choose randomly[m
[32m+[m[32m                self.next_direction = random.choice(preferred_directions)[m
[32m+[m
[32m+[m[32m            # Avoid dead ends[m
[32m+[m[32m            non_dead_end = [[m
[32m+[m[32m                d[m
[32m+[m[32m                for d in preferred_directions[m
[32m+[m[32m                if not MovementAlgorithms.is_dead_end(maze, (self.grid_x + DIRECTIONS[d][0], self.grid_y + DIRECTIONS[d][1]))[m
[32m+[m[32m            ][m
[32m+[m[32m            if non_dead_end:[m
[32m+[m[32m                self.next_direction = random.choice(non_dead_end)[m
             else:[m
[31m-                self.next_direction = random.choice(valid_directions)[m
[32m+[m[32m                random.shuffle(preferred_directions)[m
[32m+[m[32m                self.next_direction = random.choice(preferred_directions)[m
[32m+[m
[32m+[m[32m    def cycle_ai_strategy(self):[m
[32m+[m[32m        self.movement_strategy.cycle_strategy()[m
[32m+[m
[32m+[m[32m    def set_ai_strategy(self, strategy_name):[m
[32m+[m[32m        return self.movement_strategy.set_strategy(strategy_name)[m
 [m
[31m-    def render(self, screen):[m
[32m+[m[32m    def get_current_strategy(self):[m
[32m+[m[32m        return self.movement_strategy.current_strategy[m
[32m+[m
[32m+[m[32m    def get_available_strategies(self):[m
[32m+[m[32m        return self.movement_strategy.available_strategies[m
[32m+[m
[32m+[m[32m    def get_danger_level(self):[m
[32m+[m[32m        if self.is_invincible:[m
[32m+[m[32m            return "SAFE"[m
[32m+[m
[32m+[m[32m        current_pos = (self.grid_x, self.grid_y)[m
[32m+[m[32m        min_distance = float('inf')[m
[32m+[m
[32m+[m[32m        for ghost_pos in self.last_known_ghost_positions:[m
[32m+[m[32m            if ghost_pos:[m
[32m+[m[32m                distance = self.algorithms.heuristic(current_pos, ghost_pos)[m
[32m+[m[32m                min_distance = min(min_distance, distance)[m
[32m+[m
[32m+[m[32m        if min_distance <= 2:[m
[32m+[m[32m            return "CRITICAL"[m
[32m+[m[32m        elif min_distance <= 4:[m
[32m+[m[32m